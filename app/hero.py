from sqlmodel import Field, SQLModel, create_engine, Session, select, or_, col


class Hero(SQLModel, table = True):
    id: int | None = Field(default=None, primary_key=True)
    name: str = Field(index=True)  # index=True will create an index on the name column for faster queries
    secret_name: str
    age: int | None = Field(default=None, index=True)  # age is optional, so it can be None

# Create an SQLite database engine
sqlite_file_name = "database.db"
sqlite_url = f"sqlite:///db/{sqlite_file_name}"    # Each supported database has its own URL type. For example, for SQLite it is sqlite:/// followed by the file path. For example: 
                                                # sqlite:///database.db or sqlite:///databases/local/application.db
                                                # When use double // in sqilte:// means the db lives in memory, so it will not be persisted. And gets deleted when the program ends.

engine = create_engine(sqlite_url, echo=True)   #echo=True will log all the SQL statements generated by SQLModel in production is better echo = False

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)            # This will create the database tables based on the defined models if they do not already exist.

# When we declare a model with SQLModel, with the table = True argument, it means that this model will be used to create a table in the database. 
# Because of this, we can use the SQLModel.metadata.create_all(engine) method to create the table in the database.

def create_heroes():
    hero_1 = Hero(name="Deadpond", secret_name="Dive Wilson")
    hero_2 = Hero(name="Spider-Boy", secret_name="Pedro Parqueador")
    hero_3 = Hero(name="Rusty-Man", secret_name="Tommy Sharp", age=48)
    hero_4 = Hero(name="Tarantula", secret_name="Natalia Roman-on", age=32)
    hero_5 = Hero(name="Black Lion", secret_name="Trevor Challa", age=35)
    hero_6 = Hero(name="Dr. Weird", secret_name="Steve Weird", age=36)
    hero_7 = Hero(name="Captain North America", secret_name="Esteban Rogelios", age=93)

    with Session(engine) as session:
        session.add(hero_1)
        session.add(hero_2)
        session.add(hero_3)
        session.add(hero_4)
        session.add(hero_5)
        session.add(hero_6)
        session.add(hero_7)

        session.commit()    # This will commit the changes to the database, saving the heroes to the database
    # print("Before interacting with the database")
    # print("Hero 1:", hero_1)
    # print("Hero 2:", hero_2)
    # print("Hero 3:", hero_3)


        # print("After adding to the session")
        # print("Hero 1:", hero_1)
        # print("Hero 2:", hero_2)
        # print("Hero 3:", hero_3)

        # print("After committing the session, show IDs")
        # print("Hero 1 ID:", hero_1.id)
        # print("Hero 2 ID:", hero_2.id)
        # print("Hero 3 ID:", hero_3.id)

        # print("After committing the session, show names")
        # print("Hero 1 name:", hero_1.name)
        # print("Hero 2 name:", hero_2.name)
        # print("Hero 3 name:", hero_3.name)

        session.refresh(hero_1)  # This will refresh the instance with the latest data from the database prbably you need to return it.
        session.refresh(hero_2)
        session.refresh(hero_3)

    #     print("After refreshing the heroes")
    #     print("Hero 1:", hero_1)
    #     print("Hero 2:", hero_2)
    #     print("Hero 3:", hero_3)
    
    # print("After the session closes")
    # print("Hero 1:", hero_1)
    # print("Hero 2:", hero_2)
    # print("Hero 3:", hero_3)
    # session.close()  # This will close the session not necessary when using 'with' statement
def select_heroes():
    with Session(engine) as session:
        #statement = select(Hero)        # It's equivalent to the SQL SELECT * FROM hero
        # statement = select(Hero).where(or_(col(Hero.age) >= 35, col(Hero.name).endswith("America")))    # This will select all heroes with the name "Deadpond"
                                                                                                        # col is used to reference the columns of the table and don't allow SQL injection
                                                                                                        # col avoids the interpeter to confuse between the Python variable and the SQL column name
                                                                                                        # This is equivalent to the SQL: SELECT * FROM hero WHERE age >= 35 OR name LIKE '%America' 
        statement = select(Hero).where(col(Hero.age) > 32).offset(0).limit(2)     # This will select the first 3 heroes from the database, skipping the first 3 heroes 3 by 3 going through the list when we said
                                                        # OFFSET 5 LIMIT 3 it means skip the first 5 and get the next 3 so it will return heroes with id 6,7 and 8 but now we don't have 8
                                                        # Only heroes with id 6 and 7 will be returned
        results = session.exec(statement)

        # hero = session.get(Hero, 100)  # This will get the hero with id 1 from the database, if it exists
        #print(f"First Hero: {results.first()}") # This will print the first hero from the results
        # print(f"One Hero: {results.one()}") # This will print one hero from the results, if there are multiple heroes it will raise an error
        # for hero in results:  # This will iterate over the results and print each hero
        #     print(hero)
        heroes = results.all()            # This will get all the heroes from the database in list format
        # print("Heroes in the database:")
        print(heroes)
        
def update_heros():
    with Session(engine) as session:
        statement = select(Hero).where(Hero.name == "Spider-Boy")
        results = session.exec(statement)
        hero = results.one()
        print(f"Hero before update: {hero}")
        print(type(hero))
        hero.age = 16
        print(f"Hero after update: {hero}")
        session.add(hero)
        session.commit()  # This will commit the changes to the database, updating the hero's
        session.refresh(hero)  # This will refresh the instance with the latest data from the database
        print(f"Hero after refresh: {hero}")

def delete_heroes():
    with Session(engine) as session:
        statement = select(Hero).where(Hero.name == "Spider-Boy")
        results = session.exec(statement)
        hero = results.one_or_none()
        if hero:
            session.delete(hero)
            session.commit()
            print(f"Hero {hero.name} deleted successfully.")
        else:
            print("Hero not found, nothing to delete.")     # For example when we said something like Spider-Boyy or Spider-Boy1 it will not find the hero and will not delete anything

def main():
    create_db_and_tables()  # This will create the database and tables if they do not exist
    print("Database and tables created successfully.")
    create_heroes()  # This will create some heroes in the database
    print("Heroes created successfully.")
    select_heroes()  # This will select and print all heroes from the database
    print("Heroes selected successfully.")
    update_heros()  # This will update the heroes in the database
    print("Heroes updated successfully.")
    delete_heroes()  # This will delete the heroes in the database
    print("Heroes deleted successfully.")


if __name__ == "__main__":
    main()  # This will run the main function when the script is executed